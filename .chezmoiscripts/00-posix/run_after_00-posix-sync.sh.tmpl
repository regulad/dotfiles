#!{{ .bash }}
# android bash doesn't support setting flags in invocation
set -e

# =+= START CONFIGURATION =+=
# version to install
OPENJDK_LTS_VERSION=25
PYTHON_VERSION=3.12

# minimum versions of host operating systems
RHEL_MINIMUM_VERSION=9.7  # latest version of lowest-supported at publishing time
FEDORA_MINIMUM_VERSION=42  # 40/41 are EOL although would probably work, 42 oldest w/ support
MACOS_MINIMUM_VERSION=14  # tested on 14 and 26
DEBIAN_MINIMUM_VERSION=13
UBUNTU_MINIMUM_VERSION=24.04
# =+= END CONFIGURATION =+=

# Installs neccesary tools to enable everything from the dotfiles
# https://www.chezmoi.io/user-guide/use-scripts-to-perform-actions/
# NOTE!! this is ONLY for true nix. no MINGW64; will handle that separately.
# yes, i realize how dumb that this is when I could just use nix. lol.

echo "note: entering hookscript" >&2
export DEBIAN_FRONTEND=noninteractive
trap 'echo "Error on line $LINENO: Command was: $BASH_COMMAND" >&2' ERR

# needed for Android native builds
if [ "$(uname -o)" = "Android" ]; then
  export ANDROID_API_LEVEL="$(getprop ro.build.version.sdk 2>/dev/null || true)"
fi

# function definition

# Generated by GPT-5.2
# Source: RPM Fusion "Configuration" page (https://rpmfusion.org/Configuration)
# Purpose: Enable RPM Fusion free+nonfree on supported Fedora (>=41) and EL (>=8) using dnf.
enable_rpmfusion() {
	_warn() { printf 'warn: %s\n' "$*" >&2; }
	_err() { printf 'error: %s\n' "$*" >&2; }

	_is_installed() { rpm -q "$1" >/dev/null 2>&1; }

	# Silent success if already enabled.
	if _is_installed rpmfusion-free-release && _is_installed rpmfusion-nonfree-release; then
		return 0
	fi

	# Detect platform via RPM macros (as in RPM Fusion docs).
	local fedora_ver rhel_ver
	fedora_ver="$(rpm -E '%{?fedora}' 2>/dev/null || true)"
	rhel_ver="$(rpm -E '%{?rhel}' 2>/dev/null || true)"

	if [[ -n "${fedora_ver}" && "${fedora_ver}" != "%{?fedora}" ]]; then
		_is_installed rpmfusion-free-release || sudo dnf -y -q install \
			"https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-${fedora_ver}.noarch.rpm"
		_is_installed rpmfusion-nonfree-release || sudo dnf -y -q install \
			"https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-${fedora_ver}.noarch.rpm"
		return 0
	fi

	if [[ -n "${rhel_ver}" && "${rhel_ver}" != "%{?rhel}" ]]; then
		# Assumes EPEL already enabled (RPM Fusion requires it on EL).
		_is_installed rpmfusion-free-release || sudo dnf -y -q install --nogpgcheck \
			"https://mirrors.rpmfusion.org/free/el/rpmfusion-free-release-${rhel_ver}.noarch.rpm"
		_is_installed rpmfusion-nonfree-release || sudo dnf -y -q install --nogpgcheck \
			"https://mirrors.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-${rhel_ver}.noarch.rpm"
		return 0
	fi

	_err "unsupported/undetected platform (not fedora and not rhel-compatible)"
	return 2
}

# Generated by GPT-5.2
# Source: RPM Fusion "Configuration" page (https://rpmfusion.org/Configuration)
# Purpose: On EL (RHEL/clones), enable the builder repo needed by some RPM Fusion deps.
rpmfusion_enable_el_builder_repo() {
	# RHEL: CodeReady Builder
	if command -v subscription-manager >/dev/null 2>&1; then
		sudo subscription-manager repos --enable \
			"codeready-builder-for-rhel-${rhel_ver}-$(uname -m)-rpms" \
			>/dev/null 2>&1 || true
		return 0
	fi

	# RHEL clones (Alma/Rocky): CRB helper if present
	if [[ -x /usr/bin/crb ]]; then
		sudo /usr/bin/crb enable >/dev/null 2>&1 || true
		return 0
	fi

	# Otherwise: do nothing (some clones may use different tooling)
	return 0
}

# Panic if running as root or on non-Unix platform
if [[ "$EUID" -eq 0 ]] || [[ "$UID" -eq 0 ]]; then
	echo "error: this script must not be run as root or with sudo" >&2
	exit 1
fi

if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
	echo "error: this script does not support Windows/MINGW64/Cygwin environments" >&2
	exit 1
fi

if ! sudo -l &>/dev/null; then
	echo "warning: Can't sudo. Will not attempt to install things that need sudo." >&2
	CAN_SUDO=false
else
	echo "note: Successfully captured sudo. Will use it." >&2
	CAN_SUDO=true
fi

# START CLAUDE (Claude Sonnet 4.5)
# Purpose: Check that the host OS meets minimum version requirements
# Written by Claude Sonnet 4.5
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$ID
    VERSION_ID=${VERSION_ID:-0}
elif [ "$(uname)" = "Darwin" ]; then
    OS="macos"
    VERSION_ID=$(sw_vers -productVersion | cut -d. -f1)
else
    echo "Error: Unable to detect operating system"
    exit 1
fi
case "$OS" in
    rhel|centos|rocky|alma)
        REQUIRED="$RHEL_MINIMUM_VERSION"
        CURRENT=$(echo "$VERSION_ID" | cut -d. -f1)
        if [ "$(echo -e "$VERSION_ID\n$REQUIRED" | sort -V | head -n1)" != "$REQUIRED" ]; then
            echo "Error: RHEL/CentOS/Rocky/Alma $REQUIRED or higher required (found $VERSION_ID)"
            exit 1
        fi
        ;;
    fedora)
        REQUIRED="$FEDORA_MINIMUM_VERSION"
        if [ "$VERSION_ID" -lt "$REQUIRED" ]; then
            echo "Error: Fedora $REQUIRED or higher required (found $VERSION_ID)"
            exit 1
        fi
        ;;
    macos)
        REQUIRED="$MACOS_MINIMUM_VERSION"
        if [ "$VERSION_ID" -lt "$REQUIRED" ]; then
            echo "Error: macOS $REQUIRED or higher required (found $VERSION_ID)"
            exit 1
        fi
        ;;
    debian)
        REQUIRED="$DEBIAN_MINIMUM_VERSION"
        if [ "$VERSION_ID" -lt "$REQUIRED" ]; then
            echo "Error: Debian $REQUIRED or higher required (found $VERSION_ID)"
            exit 1
        fi
        ;;
    ubuntu)
        REQUIRED="$UBUNTU_MINIMUM_VERSION"
        if [ "$(echo -e "$VERSION_ID\n$REQUIRED" | sort -V | head -n1)" != "$REQUIRED" ]; then
            echo "Error: Ubuntu $REQUIRED or higher required (found $VERSION_ID)"
            exit 1
        fi
        if [ "$CAN_SUDO" = "true" ]; then
            sudo add-apt-repository -y ppa:zhangsongcui3371/fastfetch
        else
            echo "Error: sudo access required to add PPA(s) on Ubuntu"
            exit 1
        fi
        ;;
    *)
        echo "Error: Unsupported operating system: $OS"
        exit 1
        ;;
esac
# END CLAUDE (Claude Sonnet 4.5)

# Try to load homebrew if it is installed
if [[ -d "/opt/homebrew" && "$CAN_SUDO" = "true" ]]; then
	# Apple Silicon Mac (rootful)
	eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ (-d "/usr/local/Homebrew" || -d "/usr/local/bin/brew") && "$CAN_SUDO" = "true" ]]; then
	# Intel Mac (rootful)
	eval "$(/usr/local/bin/brew shellenv)"
elif [[ -d "/home/linuxbrew/.linuxbrew" && "$CAN_SUDO" = "true" ]]; then
	# Linux
	eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
elif [[ -d "$HOME/homebrew" ]]; then
	# Rootless homebrew (macOS & Linux)
	echo "warning: loading rootless brew. this often works but is unsupported." >&2
	eval "$("$HOME/homebrew/bin/brew" shellenv)"
fi

# brew is a nother binary dependency but ONLY on linux for addl. userspace packages
# don't think any of the addl. userpsace packages need to be installed by this script
if ! command -v brew &>/dev/null && [[ "$(uname -o)" == "Darwin" || "$(uname -o)" == "GNU/Linux" ]]; then
	echo "note: installing brew" >&2
	if ! [ "$CAN_SUDO" = "true" ]; then
		NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
		if [ "$(uname -o)" = "Darwin" ] && [ "$(arch)" = "arm64" ]; then
			sudo launchctl config user path /opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
			sudo launchctl config system path /opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
		elif [ "$(uname -o)" = "Darwin" ] && [ "$(arch)" = "x86_64" ]; then
			sudo launchctl config user path /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
			sudo launchctl config system path /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
		fi
	else
		echo "warning: can't do default brew install w/o sudo; installing rootlessly" >&2
		mkdir homebrew && curl -L https://github.com/Homebrew/brew/tarball/main | tar xz --strip-components 1 -C homebrew

		eval "$(homebrew/bin/brew shellenv)"
		brew update --force --quiet
		chmod -R go-w "$(brew --prefix)/share/zsh"
	fi

	# After Homebrew installation, detect and load it
	if [[ -d "/opt/homebrew" && "$CAN_SUDO" = "true" ]]; then
		# Apple Silicon Mac (rootful)
		eval "$(/opt/homebrew/bin/brew shellenv)"
	elif [[ (-d "/usr/local/Homebrew" || -d "/usr/local/bin/brew") && "$CAN_SUDO" = "true" ]]; then
		# Intel Mac (rootful)
		eval "$(/usr/local/bin/brew shellenv)"
	elif [[ -d "/home/linuxbrew/.linuxbrew" && "$CAN_SUDO" = "true" ]]; then
		# Linux
		eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
	elif [[ -d "$HOME/homebrew" ]]; then
		# Rootless homebrew (macOS & Linux)
		eval "$(homebrew/bin/brew shellenv)"
	fi
fi

export PATH="$PATH:$HOME/.local/bin"

# system-level binary dependencies
#     - these are typically very stable applications that MUST be provided by a package manager
#     - they are not particularly version-sensitive; pinning is unnecesary
#     - they are all f(l)oss
# package managers:
#     - brew (macos) [m:]
#     - apt (debian) [d:]
#     - dnf (redhat) [r:]
#     - pkg (termux) [t:]
PRIMARY_BINARY_DEPENDENCIES=(
	# =+= CORE
	"dt:build-essential"
	"mdrt:bash"
	"mdrt:tmux"
	"mdrt:fastfetch" # not available on debian older than trixie (13)
	"mdrt:telnet"
	"mdr:retry" # no compat on termux
	"mdrt:zsh"
	"t:file"
	"t:man"
	"t:tokei"
	"dt:xxd"
	"t:which"
	"md:binwalk"
	"mdrt:ncdu"
	"mdt:htop"
	"mdt:nmap"
	"m:watch"

	# =+= macOS-SPECIFIC
	"m:reattach-to-user-namespace"
	"m:mas"

	# =+= BUILD TOOLS
	"d:ninja-build"
	"mt:ninja"
	# TODO: confirm compat on others
	"mdt:cmake"

	# =+= EDITOR
	"mdrt:neovim" # nvim
	"mdrt:vim"
	"mdt:shellcheck"
	"r:ShellCheck"

	# =+= UTILS
	"mdrt:git"
	"mdrt:git-lfs"
	"mdt:gnupg" # gpg
	"r:gnupg2"
	"m:gpgme"
	"d:openssh-client"
	"mrt:openssh" # ssh-agent & ssh
	"mdrt:keychain"
	"mdrt:gh" # GitHub
	"mdrt:restic"
	"mdrt:ffmpeg"
	"md:yt-dlp" # previously managed by uv
	"t:python-yt-dlp"
	# TODO: confirm compat on redhat

	# =+= JS/TS
	"m:node"
	"dr:nodejs"
	"t:nodejs-lts"
	"mdr:npm" # just to install pnpm; part of nodejs-lts on termux
	"t:deno"

	# =+= JVM
	"m:openjdk"
	"r:java-latest-openjdk"
	"d:default-jdk"
	"t:openjdk-$OPENJDK_LTS_VERSION"
	"mdrt:maven"

	# =+= RUST
	"md:rustup"
	"r:cargo"   # part of rust on termux
	"r:rustfmt" # also part of rust on termux
	"rt:rust"
	"rt:rust-analyzer"

	# =+= PYTHON (>= 3.12)
	"mdr:python3"
	"dr:python3-pip"
	"d:python3-venv"
	"t:python"

	# =+= MISC. TOOLCHAINS
	"m:go"
	"dt:golang"
	# TODO: confirm compat for redhat
)

# choose manager
command -v brew &>/dev/null && HAS_BREW=true || HAS_BREW=false
export HOMEBREW_NO_ENV_HINTS=1

if command -v pkg &>/dev/null && [[ "$PREFIX" == *"com.termux"* ]]; then
	MANAGER="pkg"
elif command -v dnf &>/dev/null && [[ -f /etc/redhat-release ]]; then
	MANAGER="dnf"
elif command -v apt &>/dev/null && [[ -f /etc/debian_version ]]; then
	MANAGER="apt"
elif command -v brew &>/dev/null && [[ "$OSTYPE" == "darwin"* ]]; then
	MANAGER="brew"
	# Brew-specific tap setups
	brew tap regulad/homebrew-tap  # auto-uses GitHub if unspecified
	brew tap kde-mac/kde https://invent.kde.org/packaging/homebrew-kde.git && "$(brew --repo kde-mac/kde)/tools/do-caveats.sh"
else
	MANAGER=""
fi

# Check sudo requirement for dnf5 and apt
if [[ "$MANAGER" == "dnf" || "$MANAGER" == "apt" ]] && ! [ "$CAN_SUDO" = "true" ]; then
	echo "warning: package manager needs sudo but it isn't available" >&2
	MANAGER=""
fi

# Check if any manager was detected
if [[ -z "$MANAGER" ]]; then
	echo "warning: no package manager detected" >&2
fi

# Filter dependencies based on package manager
if [[ -n "$MANAGER" ]]; then
	TO_INSTALL=()
	for dep in "${PRIMARY_BINARY_DEPENDENCIES[@]}"; do
		# Extract prefix and package name
		prefix="${dep%%:*}"
		package="${dep#*:}"

		# Check if this package applies to current manager
		case "$MANAGER" in
		pkg)
			[[ -z "$prefix" || "$prefix" == *"t"* ]] && TO_INSTALL+=("$package")
			;;
		dnf)
			[[ -z "$prefix" || "$prefix" == *"r"* ]] && TO_INSTALL+=("$package")
			;;
		apt)
			[[ -z "$prefix" || "$prefix" == *"d"* ]] && TO_INSTALL+=("$package")
			;;
		brew)
			[[ -z "$prefix" || "$prefix" == *"m"* ]] && TO_INSTALL+=("$package")
			;;
		esac
	done

	# Install packages if any were found
	if [[ ${#TO_INSTALL[@]} -gt 0 ]]; then
		case "$MANAGER" in
		pkg)
			# No quietting techniques work for pkg
			pkg install -y "${TO_INSTALL[@]}"
			;;
		dnf)
			enable_rpmfusion
			rpmfusion_enable_el_builder_repo
			sudo dnf groupinstall -q -y "Development Tools"
			sudo dnf install -q -y "${TO_INSTALL[@]}"
			;;
		apt)
			sudo apt update -qq -o=Dpkg::Use-Pty=0
			sudo apt install -qq -o=Dpkg::Use-Pty=0 -y "${TO_INSTALL[@]}"
			;;
		brew)
			brew install -q "${TO_INSTALL[@]}"
			;;
		esac
	fi
fi

# Setup Rust toolchain if needed
if command -v rustup-init &>/dev/null && [[ ! -d "$HOME/.cargo" ]]; then
	rustup-init -y --default-toolchain stable --profile default
	source "$HOME/.cargo/env"
	rustup component add rust-analyzer
elif command -v rustup &>/dev/null && rustup toolchain list 2>&1 | grep -qE "(no installed toolchains|^$)"; then
	rustup default stable
	rustup set profile default
	rustup toolchain install stable
	rustup component add rust-analyzer
fi

if [ "$MANAGER" = "brew" ] && [ "$CAN_SUDO" = "true" ]; then
	# special case needed to link the openjdk into the system java wrapper
	sudo ln -sfn $HOMEBREW_PREFIX/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdk
fi

# Install zerobrew if on a platform that supports it. Zerobrew is an experimental rust rewrite of brew
if [[ $(uname -m) == "arm64" && $(uname -s) == "Darwin" && "$SHELL" == *"zsh"* ]]; then
	# This install script is idempotent. 
	source ~/.zshenv
	curl -sSL https://raw.githubusercontent.com/lucasgelfond/zerobrew/main/install.sh | bash
fi

# user-level binary dependencies
# these dependencies aren't provided by the system package manager, for whatever reason
# these packages do NOT require compilation and are distributed as binaries.
# they may be closed-source/non-libre (although I don't think any are).
# brew distributes these on GNU/Linux and Darwin. no attempt is made on other platforms
# most of them are needed for specific workflows (i.e. kotlin, python, java)
SECONDARY_BINARY_DEPENDENCIES=(
	"wakatime-cli"
	"neovim"  # newer version than available on main toolchains
	"ollama"
	"tokei"
	"minio-mc"
	"wasm-tools"
	"kotlin"
	"kotlin-language-server"
	"fernflower"
	"jdtls"
	"emscripten"
	"harper"
	"lima"
	"lima-additional-guestagents"
	"deno"
	"shfmt"
	"ghidra"
	"oven-sh/bun/bun"  # addl. javascript runtime
#	"dicklesworthstone/tap/cass"  # completely broken, ai slop took over they packaging pipeline
	"msmtp"
	"isync"
	"poppler"
	"tesseract"
	"ocrmypdf"
	"neomutt"
	"s3cmd"
	"rclone"
)

if [ "$HAS_BREW" = "true" ]; then
	brew install -q "${SECONDARY_BINARY_DEPENDENCIES[@]}"
else
	echo "warning: no brew for misc. binary deps" >&2
fi

## addl. brew things packaged as casks
BREW_CASKS_MACOS=(
	"adobe-digital-editions" # proprietary!
	"handbrake-app"
	"grandperspective"
	"claude-code"       # proprietary!
	"jetbrains-toolbox" # proprietary!
	"raycast"
	"gimp"
	"signal"
	"tailscale-app" # proprietary! ... kinda
	"appcleaner"    # no idea
	"google-chrome" # proprietary! (you can't make me use anything other than chrome)
	"nextcloud-vfs"
	"docker-desktop"
	"obs"
	"utm"
	"bartender" # proprietary! i have a license
	"grandperspective"
	"onedrive"
	"stats"
	"vlc"
	"calibre"
	"hex-fiend"
	"google-drive" # proprietary!
	"visual-studio-code"
	"autodesk-fusion"  # proprietary!
	"thunderbird@esr"
#	"kde-mac/kde/kdeconnect"  # broken 1/29/26
)
### excluded: exclusively GUI tools like discord, steam, signal, & spotify that don't enable any workflows

if [ "$HAS_BREW" = "true" ] && [[ "$OSTYPE" == "darwin"* ]]; then
	echo "warning: brew is about to install casks. this will take over any existing non-brew managed installs" >&2
	brew install --cask -q "${BREW_CASKS_MACOS[@]}" -f
fi

## cask library on linux is SUBSTANTIALLY different than the cask library on macos
BREW_CASKS_LINUX=(
	"claude-code" # proprietary!
)

if [ "$HAS_BREW" = "true" ] && [[ "$OSTYPE" == "linux-gnu"* ]]; then
	echo "warning: brew is about to install casks. this will take over any existing non-brew managed installs" >&2
	brew install --cask -q "${BREW_CASKS_LINUX[@]}" -f
fi

# pnpm
if [ "$HAS_BREW" = "true" ]; then
	brew install -q pnpm
elif [ "$CAN_SUDO" = "true" ]; then
	sudo npm i -g -q pnpm@latest
else
	npm install -g --prefix ~/.local -q pnpm@latest
fi

if [ -z "$PNPM_HOME" ]; then
	touch ~/.bashrc
	mv ~/.bashrc ~/.bashrc.pre-pnpm
	SHELL=bash pnpm setup &>/dev/null
	source ~/.bashrc
	rm ~/.bashrc
	mv ~/.bashrc.pre-pnpm ~/.bashrc
fi

PNPM_CLI_PACKAGES=(
	"@continuedev/cli@latest"
	"ezff@latest"
)

# these need to be installed with base NPM
NPM_CLI_PACKAGES=(
	"opencode-ai@latest"
#	"opencode-swarm-plugin@latest"  # this application is an incredible piece of horseshit. doesn't even try
)

## packages available on brew are preferred over their pnpm packages (may have binary bottles pre-built)
if [ "$HAS_BREW" = "true" ]; then
	brew install -q \
		bitwarden-cli \
		typescript \
		typescript-language-server \
		bash-language-server \
		yaml-language-server
else
	PNPM_CLI_PACKAGES+=(
		"@bitwarden/cli@latest" 
		"typescript@latest" 
		"typescript-language-server@latest" 
		"bash-language-server@latest"
		"yaml-language-server@latest"
	)
fi

pnpm i -g --silent "${PNPM_CLI_PACKAGES[@]}"
npm install -g "${NPM_CLI_PACKAGES[@]}"

# deno
export DENO_INSTALL="$HOME/.deno"
export PATH="$DENO_INSTALL/bin:$PATH"

## minecraft fabric
if ! command -v fabric &>/dev/null; then
	deno install -A -g -n fabric https://fabricmc.net/cli
else
	fabric upgrade
fi

# Poetry
# NOTE: redhat repositories provide poetry-core but not the CLI
# NOTE: on brew platforms, the --user pip environment is externally handled
if [ "$MANAGER" = "apt" ]; then
	sudo apt install -qq -o=Dpkg::Use-Pty=0 -y python3-poetry
elif [ "$HAS_BREW" = "true" ]; then
	brew install -q poetry
else
	pip install --user -q poetry
fi

# UV
if [ "$HAS_BREW" = "true" ]; then
	brew install -q uv
elif [ "$MANAGER" = "pkg" ]; then
	pkg install -y uv
else
	pip install --user -q uv
fi

# NOTE: poetry is for legacy workflows.
# NOTE: `uv tool install` replaces pipx
# can install with `pipx i <package>`
# or `uv tool install <package>`
# NOTE: uv deliberately ignores upper bounds on requires-python,
#       which boosts speed since pip likes to "backstep" and take
#       the highest package version which supports the python version.
#
#       This leads to issues with code that requires stable ABI presence.
#
#       I have chosen to only download tools with uv against known-good python versions.
#
#       For durability, I have offloaded the management of some packages like `yt-dlp`
#       to native package managers that test against specific python versions.
#
#       This can be changed if the python-requires spec at https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata-requires-python
#       is ever updated to better accomidate the Python ecosystem with its alternative implementations and ABIs.
#
#       Until then, for cli apps, I will be using the lowest version of Cpython that has is checked.
uv tool install -q ruff # astral-backed
uv tool install -q ty   # astral-backed
uv tool install --python cp310 -q "git+https://github.com/regulad/keymap-renderer.git@master"
uv tool install -q "rendercv[full]"

# rust
cargo install cargo-disasm

# go
go install mvdan.cc/sh/v3/cmd/shfmt@latest

# vim package management
# NOTE: because I use neovim in lieu of vim, I'm not going to install Vundle
# lazy doesn't need to be installed itself but it does need some native dependencies

# oh my zsh
if ! [ -d ~/.oh-my-zsh ]; then
	# oh my zsh install process mutates the user's ~/.zshrc and there is no way to disable this behaviour
	touch ~/.zshrc
	mv ~/.zshrc ~/.zshrc.pre-oh-my-zsh
	sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended &>/dev/null
	rm ~/.zshrc
	mv ~/.zshrc.pre-oh-my-zsh ~/.zshrc
else
	~/.oh-my-zsh/tools/upgrade.sh
fi

if [ -d ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions ]; then
	git -C ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions pull
else
	git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions
fi


# these commands only run on non-cattle hosts (persistent)
# load zsh as primary shell
ZSH_PATH=$(command -v zsh)

if command -v chsh &>/dev/null && ! [ "$(uname -o)" = "Android" ]; then
	# Check if detected zsh is in /etc/shells
	if [ -n "$ZSH_PATH" ] && ! grep -q "^$ZSH_PATH$" /etc/shells; then
		echo "warning: $ZSH_PATH not in /etc/shells, using zsh in /etc/shells if exists" >&2
		ZSH_PATH=$(grep -m1 '/zsh$' /etc/shells)
	fi

	# If no zsh in /etc/shells, fall back to bash
	if [ -z "$ZSH_PATH" ]; then
		echo "warning: falling back to bash since zsh isn't available in /etc/shells" >&2

		BASH_PATH=$(command -v bash)

		if [ -n "$BASH_PATH" ] && ! grep -q "^$BASH_PATH$" /etc/shells; then
			echo "warning: $BASH_PATH not in /etc/shells, using bash in /etc/shells if exists" >&2
			BASH_PATH=$(grep -m1 '/bash$' /etc/shells)
		fi

		if [ -z "$BASH_PATH" ]; then
			echo "error: no valid shell found in /etc/shells" >&2
			exit 1
		fi

		SHELL_PATH="$BASH_PATH"
	else
		SHELL_PATH="$ZSH_PATH"
	fi

	# Change shell if not already set
	if [ "$SHELL" != "$SHELL_PATH" ]; then
		if [ "$CAN_SUDO" = "true" ]; then
			sudo chsh -s "$SHELL_PATH"
		else
			chsh -s "$SHELL_PATH"
		fi
		echo "note: shell was changed" >&2
	fi
elif command -v chsh &>/dev/null; then
	chsh -s zsh
else
	echo "warning: could not autoset shell" >&2
fi

# final step: upgrade dependencies but ONLY for user-level pms
if [ "$HAS_BREW" = "true" ]; then
	brew upgrade -q
	brew upgrade -q --cask
	brew cleanup -q
fi
pnpm update --global --silent
uv tool upgrade --quiet --all

# Certificate installation
# NOTE: chezmoi source-path can't be used if this is in an apply
CERT_PATHS=(
	"$HOME/.local/share/chezmoi/dot_x509/ipa-ca.crt"
)

# Detect OS and install certificates
if [[ "$(uname -o)" == "Android" ]]; then
	# Termux/Android
	echo "note: on Android/Termux, certificates must be added manually to the system trust store" >&2

elif [[ "$OSTYPE" == "darwin"* ]]; then
	# macOS
	for CERT_PATH in "${CERT_PATHS[@]}"; do
		# Check if certificate is already trusted
		if ! security verify-cert -c "$CERT_PATH" &>/dev/null; then
			if [ "$CAN_SUDO" = "true" ]; then
				sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain "$CERT_PATH"
			else
				security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db "$CERT_PATH"
				echo "warning: added certificate to user keychain only (no sudo available)" >&2
			fi
		fi
	done

elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
	# Linux
	if [ "$CAN_SUDO" = "true" ]; then
		NEEDS_UPDATE=0

		for CERT_PATH in "${CERT_PATHS[@]}"; do
			# Check if certificate is already in system trust store
			if ! openssl verify -CApath /etc/ssl/certs "$CERT_PATH" &>/dev/null; then
				CERT_NAME=$(basename "$CERT_PATH")

				if [ -d /etc/pki/ca-trust/source/anchors ]; then
					# RHEL/CentOS/Fedora
					sudo cp "$CERT_PATH" "/etc/pki/ca-trust/source/anchors/$CERT_NAME"
					NEEDS_UPDATE=1
				elif [ -d /usr/local/share/ca-certificates ]; then
					# Debian/Ubuntu
					sudo cp "$CERT_PATH" "/usr/local/share/ca-certificates/$CERT_NAME"
					NEEDS_UPDATE=1
				fi
			fi
		done

		# Update trust store only if new certs were added
		if [ "$NEEDS_UPDATE" -eq 1 ]; then
			if [ -d /etc/pki/ca-trust/source/anchors ]; then
				sudo update-ca-trust
			elif [ -d /usr/local/share/ca-certificates ]; then
				sudo update-ca-certificates
			fi
		fi
	else
		echo "warning: sudo required to install system certificate on Linux, skipping" >&2
	fi
fi

# install user services
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
	if systemctl --user is-system-running &>/dev/null || systemctl --user status &>/dev/null; then
		systemctl --user enable tmux@default.socket
	else
		echo "warning: user session broken (couldn't run systemd --user)" >&2
	fi
fi

echo "note: exiting hookscript. don't buy it if something after this point asks for sudo!" >&2
