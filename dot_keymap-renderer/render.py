from pathlib import Path
from tempfile import TemporaryDirectory
from copy import deepcopy
from json import load
import random
import sys
from json5 import loads as loads5
from typing import Annotated, Generator

import typer
from py_markdown_table.markdown_table import markdown_table
from xdg_base_dirs import xdg_config_home
from markdown_pdf import MarkdownPdf, Section
from jsonschema import validate

from keyboard import Keyboard
from key import Key


# python 3.10 doesn't support "type"
KEYLAYER = dict


# consts
ACTIVE_MODIFIER_COLOR = "#33ff33"
INACTIVE_LAYER_KEY_COLOR_MULTIPLIER = 0.4


def layer_generator(
    modifier: list[str] | None, layer: KEYLAYER
) -> Generator[tuple[list[str] | None, KEYLAYER], None, None]:
    yield modifier, layer
    for submodifier, sublayer in layer["sublayers"].items():
        yield from layer_generator(
            (
                (modifier + [submodifier])
                if isinstance(modifier, list)
                else [submodifier]
            ),
            sublayer,
        )


def find_key_for_selector(
    board: Keyboard, key_title: str
) -> Generator[Key, None, None]:
    search_term: str
    match key_title:
        case "<C>":
            search_term = "Ctrl"
        case "<M>":
            search_term = "Win"
        case "<A>":
            search_term = "Alt"
        case "<S>":
            search_term = "Shift"
        case "<Space>":
            return  # TODO
        case "<Enter>":
            search_term = "Enter"
        case "<Tab>":
            search_term = "Tab"
        case "<Escape>":
            search_term = "Esc"
        case "<Backspace>":
            search_term = "Backspace"
        case "<Delete>":
            search_term = "Delete"
        case "<Home>":
            search_term = "Home"
        case "<End>":
            search_term = "End"
        case "<PageUp>":
            search_term = "PgUp"
        case "<PageDown>":
            search_term = "PgDn"
        case "<Insert>":
            search_term = "Insert"
        case "<Up>":
            search_term = "↑"
        case "<Down>":
            search_term = "↓"
        case "<Left>":
            search_term = "←"
        case "<Right>":
            search_term = "→"
        case "<NumLock>":
            search_term = "Num Lock"
        case "<NumDiv>":
            return  # TODO
        case "<NumMul>":
            return  # TODO
        case "<NumSub>":
            return  # TODO
        case "<NumAdd>":
            return  # TODO
        case "<NumEnter>":
            return  # TODO
        case "<NumDot>":
            return  # TODO
        case (
            "<Num0>",
            "<Num1>",
            "<Num2>",
            "<Num3>",
            "<Num4>",
            "<Num5>",
            "<Num6>",
            "<Num7>",
            "<Num8>",
            "<Num9>",
        ):
            return  # TODO
        case _:
            search_term = key_title.upper()
    for key in board.keys:
        while len(key.labels) < 12:
            key.labels.append("")
        if search_term in set(key.labels[0:4] + key.labels[5:12]):  
            # need to skip over the edge lower where we inject the label
            # this is a generator for the modifiers who may have multiple keys on the keyboard
            yield key


def modify_color(original_color: str) -> str:
    """
    Multiply each RGB component of a hex color by a modifier.

    Note: This function darkens the color but does not reduce saturation.
    Generated by Claude.

    Args:
        original_color (str): Hex color string (e.g., '#FF0000' or 'FF0000')
        INACTIVE_LAYER_COLOR_MODIFIER (float): Multiplier for each component (e.g., 0.7)

    Returns:
        str: Modified hex color string with '#' prefix
    """
    # Remove '#' if present
    color = original_color.lstrip("#")

    # Extract RGB components
    r = int(color[0:2], 16)
    g = int(color[2:4], 16)
    b = int(color[4:6], 16)

    # Multiply each component
    r = int(r * INACTIVE_LAYER_KEY_COLOR_MULTIPLIER)
    g = int(g * INACTIVE_LAYER_KEY_COLOR_MULTIPLIER)
    b = int(b * INACTIVE_LAYER_KEY_COLOR_MULTIPLIER)

    # Clamp values to 0-255 range
    r = max(0, min(255, r))
    g = max(0, min(255, g))
    b = max(0, min(255, b))

    # Convert back to hex
    return f"#{r:02x}{g:02x}{b:02x}"


def main(
    kdl_file: Annotated[Path, typer.Argument()],
    kle_file: Annotated[Path, typer.Option()] = xdg_config_home() / "kmr" / "base.json",
    out: Annotated[Path | None, typer.Option()] = None,
) -> None:
    if out is None:
        out = kdl_file.with_suffix(".pdf")

    with TemporaryDirectory() as tempdir:
        temppath = Path(tempdir)
        pdf = MarkdownPdf(toc_level=2, optimize=True)

        with open(kdl_file, "r") as kdl_fp:
            kdl = load(kdl_fp)

        with open(
            Path(__file__).resolve().parent.joinpath("kdl.schema.json"), "r"
        ) as schema_fp:
            kdl_schema = load(schema_fp)

        validate(instance=kdl, schema=kdl_schema)

        with open(kle_file, mode="r") as kle_fp:
            # the kle format is actually a js object, not json.

            match kle_file.suffix:
                case ".js":
                    rows = [loads5(row.rstrip(",\n")) for row in kle_fp]
                    kle_deserialized = Keyboard(rows)
                case ".json":
                    kle_deserialized = Keyboard(load(kle_fp))
                case _:
                    print("KLE file has invalid extension")
                    exit(1)

        for modifier, layer in layer_generator(None, kdl):
            layer_name = layer["title"]
            this_layer_keyboard = deepcopy(kle_deserialized)

            binds = [({"key": key} | bind) for key, bind in layer["binds"].items()]

            modified_keys: set[Key] = set()

            for bind in binds:
                bind_key = bind["key"]
                short = bind["short"]
                for maybe_key in find_key_for_selector(this_layer_keyboard, bind_key):
                    while len(maybe_key.labels) < 12:
                        maybe_key.labels.append("")
                    maybe_key.labels[4] = short
                    modified_keys.add(maybe_key)

            if modifier is not None:
                all_modifier_keys: list[Key] = []
                search_terms: list[str] = []
                for modifier_str in modifier:
                    if "-" in modifier_str:
                        component_modifiers = [
                            f"<{flag}>"
                            for flag in modifier_str.lstrip("<").rstrip(">").split("-")
                        ]
                        search_terms.extend(component_modifiers)
                    else:
                        search_terms.append(modifier_str)
                for search_term in search_terms:
                    all_modifier_keys.extend(
                        find_key_for_selector(this_layer_keyboard, search_term)
                    )
                for modifier_key in all_modifier_keys:
                    modifier_key.color = ACTIVE_MODIFIER_COLOR
                modified_keys.update(all_modifier_keys)

            # Desaturate keys not on the layer
            for unmodified_key in set(this_layer_keyboard.keys) - modified_keys:
                unmodified_key.color = modify_color(unmodified_key.color)
                # TODO: this is meant to make unactivated keys have their labels dimmed,
                #       however it appears this array is borrowed and doesn't get copied right, mutating
                #       one key appears to affect other keys.
                # for i in range(0, 12):
                #     unmodified_key.label_colors[i] = modify_color(
                #         unmodified_key.label_colors[i]
                #     )

            # I'm too used to rust. I keep seeing copying...
            with this_layer_keyboard.render() as image:
                image_uri = temppath / f"{random.randint(0, sys.maxsize)}.png"
                image.save(image_uri, format="PNG")

            markdown_body = f"""
{"#" if modifier is None else "##"} {layer_name}

![{layer_name}]({str(image_uri).lstrip("/")})

{markdown_table(binds).get_markdown()}
            """

            if modifier is not None:
                markdown_body = (
                    " ".join(modifier).replace("<", "&lt;").replace(">", "&gt;")
                    + "\n"
                    + markdown_body
                )

            pdf.add_section(
                Section(
                    markdown_body,
                    root="/",
                )
            )
        pdf.save(out)


if __name__ == "__main__":
    typer.run(main)
